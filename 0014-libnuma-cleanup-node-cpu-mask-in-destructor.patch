From 24514624d5d3121884344b2847b0e50204b2ffb8 Mon Sep 17 00:00:00 2001
From: Sanskriti Sharma <sansharm@redhat.com>
Date: Tue, 9 Oct 2018 15:15:25 -0400
Subject: [PATCH 14/25] libnuma: cleanup node cpu mask in destructor

Free node_cpu_mask_v2[] bitmap-pointer-array and all of the bitmaps
that it points to.

Fixes the following valgrind warnings:

  16 bytes in 1 blocks are still reachable in loss record 1 of 3
     at 0x4C28BE3: malloc (vg_replace_malloc.c:299)
     by 0x4E37E05: numa_bitmask_alloc (libnuma.c:210)
     by 0x4E3998E: numa_node_to_cpus@@libnuma_1.2 (libnuma.c:1381)
     by 0x4E3A3C9: numa_run_on_node (libnuma.c:1718)
     by 0x402DB5: test (in /home/sansharm/src/numactl/.libs/numademo)
     by 0x401672: main (in /home/sansharm/src/numactl/.libs/numademo)

  512 bytes in 1 blocks are still reachable in loss record 2 of 3
     at 0x4C2A975: calloc (vg_replace_malloc.c:711)
     by 0x4E37E24: numa_bitmask_alloc (libnuma.c:214)
     by 0x4E3998E: numa_node_to_cpus@@libnuma_1.2 (libnuma.c:1381)
     by 0x4E3A3C9: numa_run_on_node (libnuma.c:1718)
     by 0x402DB5: test (in /home/sansharm/src/numactl/.libs/numademo)
     by 0x401672: main (in /home/sansharm/src/numactl/.libs/numademo)

  8,192 bytes in 1 blocks are still reachable in loss record 3 of 3
     at 0x4C2A975: calloc (vg_replace_malloc.c:711)
     by 0x4E39974: init_node_cpu_mask_v2 (libnuma.c:1266)
     by 0x4E39974: numa_node_to_cpus@@libnuma_1.2 (libnuma.c:1361)
     by 0x4E3A3C9: numa_run_on_node (libnuma.c:1718)
     by 0x402DB5: test (in /home/sansharm/src/numactl/.libs/numademo)
     by 0x401672: main (in /home/sansharm/src/numactl/.libs/numademo)

Signed-off-by:Sanskriti Sharma <sansharm@redhat.com>
---
 libnuma.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/libnuma.c b/libnuma.c
index eb99567..658ee00 100644
--- a/libnuma.c
+++ b/libnuma.c
@@ -103,6 +103,8 @@ numa_init(void)
 	memset(&numa_no_nodes, 0, sizeof(numa_no_nodes));
 }
 
+static void cleanup_node_cpu_mask_v2();
+
 #define FREE_AND_ZERO(x) if (x) {	\
 		numa_bitmask_free(x);	\
 		x = NULL;		\
@@ -118,6 +120,7 @@ numa_fini(void)
 	FREE_AND_ZERO(numa_no_nodes_ptr);
 	FREE_AND_ZERO(numa_memnode_ptr);
 	FREE_AND_ZERO(numa_nodes_ptr);
+	cleanup_node_cpu_mask_v2();
 }
 
 /*
@@ -1248,6 +1251,20 @@ static init_node_cpu_mask_v2(void)
 	node_cpu_mask_v2 = calloc (nnodes, sizeof(struct bitmask *));
 }
 
+static void cleanup_node_cpu_mask_v2(void)
+{
+	if (node_cpu_mask_v2) {
+		int i;
+		int nnodes;
+		nnodes = numa_max_possible_node_v2_int() + 1;
+		for (i = 0; i < nnodes; i++) {
+			FREE_AND_ZERO(node_cpu_mask_v2[i]);
+		}
+		free(node_cpu_mask_v2);
+		node_cpu_mask_v2 = NULL;
+	}
+}
+
 /* This would be better with some locking, but I don't want to make libnuma
    dependent on pthreads right now. The races are relatively harmless. */
 int
-- 
1.8.3.1

